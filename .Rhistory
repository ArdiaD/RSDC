N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- f_simul_tvtp(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
# Quick check of states vs exogenous variable
head(data.frame(Time = 1:10,
Exog = round(exog_var[1:10], 2),
State = sim_data$states[1:10]))
tail(data.frame(Time = 200:209,
Exog = round(exog_var[200:209], 2),
State = sim_data$states[200:209]))
residuals <- sim_data$observations # our data matrix
# 1. Constant correlation (no regimes)
fit_const <- estimate_model(method = "const",
residuals = residuals,
control = list(do_trace = FALSE))
# 2. Regime-switching with no exogenous variables (fixed P)
fit_noX <- estimate_model(method = "noX",
residuals = residuals,
N = 2,
control = list(do_trace = FALSE))
# 3. Regime-switching with time-varying transition probabilities
fit_tvtp <- estimate_model(method = "tvtp",
residuals = residuals,
N = 2,
X = X,
control = list(do_trace = FALSE))
# Extract estimated correlation in each regime:
round(fit_tvtp$correlations, 3) # Compare with true correlations (0.8 and -0.6)
# Extract average transition matrix for TVTP model:
round(fit_tvtp$transition_matrix, 3)
# Estimated fixed transition matrix in noX model:
round(fit_noX$transition_matrix, 3)
# Extract beta tvtp:
round(fit_tvtp$beta, 3)
logLik_const <- fit_const$log_likelihood
logLik_noX <- fit_noX$log_likelihood
logLik_tvtp <- fit_tvtp$log_likelihood
n <- nrow(residuals)
# Parameter counts:
k_const <- K*(K-1)/2
# =1 parameter
k_noX <- (2*(2-1)) + 2*(K*(K-1)/2)
# = 2 + 2*1 = 4 parameters
k_tvtp <- (2 * ncol(X)) + 2*(K*(K-1)/2)
# = (2*2) + 2*1 = 6 parameters
BIC_const <- log(n)*k_const - 2*logLik_const
BIC_noX <- log(n)*k_noX - 2*logLik_noX
BIC_tvtp <- log(n)*k_tvtp - 2*logLik_tvtp
c(BIC_const, BIC_noX, BIC_tvtp)
forecast <- f_forecast_cov(method = "tvtp",
N = 2,
residuals = residuals,
X = X,
final_params = fit_tvtp,
sigma_matrix = matrix(1, nrow = T, ncol = K),
value_cols = 1:K,
out_of_sample = FALSE)
# forecast is a list:
names(forecast)
plot(forecast$smoothed_probs[1, ], type = "l",
col = "blue", lwd = 2,
ylab = "Smoothed Probability",
xlab = "Time",
main = "Smoothed Probability of Regime 1")
# Compute dynamic minimum-variance and max-diversification weights
port_minvar <- f_minvar(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
port_maxdiv <- f_maxdiv(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
# Examine the first few weight vectors:
head(port_minvar$weights, 5)
head(port_maxdiv$weights, 5)
devtools::load_all(".")
devtools::install("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC")
library(RSDC)
set.seed(123)
T <- 500
K <- 2
N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- rsdc_simulate(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
# Quick check of states vs exogenous variable
head(data.frame(Time = 1:10,
Exog = round(exog_var[1:10], 2),
State = sim_data$states[1:10]))
tail(data.frame(Time = 200:209,
Exog = round(exog_var[200:209], 2),
State = sim_data$states[200:209]))
residuals <- sim_data$observations # our data matrix
# 1. Constant correlation (no regimes)
fit_const <- rsdc_estimate(method = "const",
residuals = residuals,
control = list(do_trace = FALSE))
# 2. Regime-switching with no exogenous variables (fixed P)
fit_noX <- rsdc_estimate(method = "noX",
residuals = residuals,
N = 2,
control = list(do_trace = FALSE))
# 3. Regime-switching with time-varying transition probabilities
fit_tvtp <- rsdc_estimate(method = "tvtp",
residuals = residuals,
N = 2,
X = X,
control = list(do_trace = FALSE))
devtools::load_all(".")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
devtools::install("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC")
library(RSDC)
set.seed(123)
T <- 500
K <- 2
N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- rsdc_simulate(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
library(RSDC)
set.seed(123)
T <- 500
K <- 2
N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- rsdc_simulate(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
# Quick check of states vs exogenous variable
head(data.frame(Time = 1:10,
Exog = round(exog_var[1:10], 2),
State = sim_data$states[1:10]))
tail(data.frame(Time = 200:209,
Exog = round(exog_var[200:209], 2),
State = sim_data$states[200:209]))
residuals <- sim_data$observations # our data matrix
# 1. Constant correlation (no regimes)
fit_const <- rsdc_estimate(method = "const",
residuals = residuals,
control = list(do_trace = FALSE))
# 2. Regime-switching with no exogenous variables (fixed P)
fit_noX <- rsdc_estimate(method = "noX",
residuals = residuals,
N = 2,
control = list(do_trace = FALSE))
# 3. Regime-switching with time-varying transition probabilities
fit_tvtp <- rsdc_estimate(method = "tvtp",
residuals = residuals,
N = 2,
X = X,
control = list(do_trace = FALSE))
devtools::install("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC")
library(RSDC)
set.seed(123)
T <- 500
K <- 2
N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- rsdc_simulate(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
# Quick check of states vs exogenous variable
head(data.frame(Time = 1:10,
Exog = round(exog_var[1:10], 2),
State = sim_data$states[1:10]))
tail(data.frame(Time = 200:209,
Exog = round(exog_var[200:209], 2),
State = sim_data$states[200:209]))
residuals <- sim_data$observations # our data matrix
# 1. Constant correlation (no regimes)
fit_const <- rsdc_estimate(method = "const",
residuals = residuals,
control = list(do_trace = FALSE))
# 2. Regime-switching with no exogenous variables (fixed P)
fit_noX <- rsdc_estimate(method = "noX",
residuals = residuals,
N = 2,
control = list(do_trace = FALSE))
# 3. Regime-switching with time-varying transition probabilities
fit_tvtp <- rsdc_estimate(method = "tvtp",
residuals = residuals,
N = 2,
X = X,
control = list(do_trace = FALSE))
# Extract estimated correlation in each regime:
round(fit_tvtp$correlations, 3) # Compare with true correlations (0.8 and -0.6)
# Extract average transition matrix for TVTP model:
round(fit_tvtp$transition_matrix, 3)
# Estimated fixed transition matrix in noX model:
round(fit_noX$transition_matrix, 3)
# Extract beta tvtp:
round(fit_tvtp$beta, 3)
logLik_const <- fit_const$log_likelihood
logLik_noX <- fit_noX$log_likelihood
logLik_tvtp <- fit_tvtp$log_likelihood
n <- nrow(residuals)
# Parameter counts:
k_const <- K*(K-1)/2
# =1 parameter
k_noX <- (2*(2-1)) + 2*(K*(K-1)/2)
# = 2 + 2*1 = 4 parameters
k_tvtp <- (2 * ncol(X)) + 2*(K*(K-1)/2)
# = (2*2) + 2*1 = 6 parameters
BIC_const <- log(n)*k_const - 2*logLik_const
BIC_noX <- log(n)*k_noX - 2*logLik_noX
BIC_tvtp <- log(n)*k_tvtp - 2*logLik_tvtp
c(BIC_const, BIC_noX, BIC_tvtp)
forecast <- rsdc_forecast(method = "tvtp",
N = 2,
residuals = residuals,
X = X,
final_params = fit_tvtp,
sigma_matrix = matrix(1, nrow = T, ncol = K),
value_cols = 1:K,
out_of_sample = FALSE)
# forecast is a list:
names(forecast)
plot(forecast$smoothed_probs[1, ], type = "l",
col = "blue", lwd = 2,
ylab = "Smoothed Probability",
xlab = "Time",
main = "Smoothed Probability of Regime 1")
# Compute dynamic minimum-variance and max-diversification weights
port_minvar <- rsdc_minvar(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
port_maxdiv <- rsdc_maxdiv(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
# Examine the first few weight vectors:
head(port_minvar$weights, 5)
head(port_maxdiv$weights, 5)
devtools::load_all(".")
forecast <- rsdc_forecast(method = "tvtp",
N = 2,
residuals = residuals,
X = X,
final_params = fit_tvtp,
sigma_matrix = matrix(1, nrow = T, ncol = K),
value_cols = 1:K,
out_of_sample = FALSE)
# forecast is a list:
names(forecast)
plot(forecast$smoothed_probs[1, ], type = "l",
col = "blue", lwd = 2,
ylab = "Smoothed Probability",
xlab = "Time",
main = "Smoothed Probability of Regime 1")
# Compute dynamic minimum-variance and max-diversification weights
port_minvar <- rsdc_minvar(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
port_maxdiv <- rsdc_maxdiv(sigma_matrix = forecast$sigma_matrix,
value_cols = 1:K,
predicted_corr = forecast$predicted_correlations,
y = residuals,
rebalance = c("daily"),
long_only = TRUE)
# Examine the first few weight vectors:
head(port_minvar$weights, 5)
head(port_maxdiv$weights, 5)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/setup.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/helper-data.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-hamilton.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-estimate-model.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/setup.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/helper-data.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-hamilton.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/setup.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/helper-data.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-hamilton.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-likelihood-nox.R", echo = TRUE)
devtools::load_all(".")
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-likelihood-nox.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-likelihood-nox.R", echo = TRUE)
1e-1
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-likelihood-nox.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-likelihood-nox.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-simulate.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-minvar-maxdiv.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-forecast.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-rsdc-estimate.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-rsdc-estimate.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-rsdc-estimate.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-rsdc-estimate.R", echo = TRUE)
source("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC/tests/testthat/test-rsdc-estimate.R", echo = TRUE)
??RSDC
?RSDC
tools::showNonASCIIfile("R/model_fit.R")
tools::showNonASCIIfile("R/simulate_data.R")
devtools::install("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
devtools::install("C:/Users/benj0/Dropbox/projet/_collaboration/project - correlation/Code BS/RSDC")
library(RSDC)
set.seed(123)
T <- 500
K <- 2
N <- 2
# Create exogenous series: a sine wave between -1 and 1
t_seq <- seq(0, 4 * pi, length.out = T)
exog_var <- sin(t_seq)
# Combine with a column of 1s for intercept
X <- cbind(1, exog_var)
# Define true coefficient arrays (N x N x p)
p <- ncol(X) # which is 2 in this case (intercept + one covariate)
beta_array <- array(0, dim = c(N, N, p))
# Set beta[i,i,] as defined above, and beta[i,j,] = 0 for i≠j
beta_array[1, 1, ] <- c(1, 2) # beta1 (for staying in regime 1)
beta_array[1, 2, ] <- c(0, 0) # not used (off-diagonal)
beta_array[2, 2, ] <- c(1, -2) # beta2 (for staying in regime 2)
beta_array[2, 1, ] <- c(0, 0) # not used
# Define regime correlation matrices
rho1 <- 0.8 # correlation in regime 1
rho2 <- -0.6 # correlation in regime 2
R1 <- matrix(c(1, rho1, rho1, 1), nrow = K)
R2 <- matrix(c(1, rho2, rho2, 1), nrow = K)
sigma_array <- array(0, dim = c(K, K, N))
sigma_array[, , 1] <- R1
sigma_array[, , 2] <- R2
# Regime means (zero for both regimes in this example)
mu_matrix <- matrix(0, nrow = N, ncol = K)
# Simulate the process
sim_data <- rsdc_simulate(n = T,
X = X,
beta = beta_array,
mu = mu_matrix,
sigma = sigma_array,
N = N,
seed = 123)
# Quick check of states vs exogenous variable
head(data.frame(Time = 1:10,
Exog = round(exog_var[1:10], 2),
State = sim_data$states[1:10]))
tail(data.frame(Time = 200:209,
Exog = round(exog_var[200:209], 2),
State = sim_data$states[200:209]))
residuals <- sim_data$observations # our data matrix
# 1. Constant correlation (no regimes)
fit_const <- rsdc_estimate(method = "const",
residuals = residuals,
control = list(do_trace = FALSE))
# 2. Regime-switching with no exogenous variables (fixed P)
fit_noX <- rsdc_estimate(method = "noX",
residuals = residuals,
N = 2,
control = list(do_trace = FALSE))
# 3. Regime-switching with time-varying transition probabilities
fit_tvtp <- rsdc_estimate(method = "tvtp",
residuals = residuals,
N = 2,
X = X,
control = list(do_trace = FALSE))
read.dcf("DESCRIPTION")
